\documentclass[aspectratio=169, table]{beamer}

\usepackage[utf8]{inputenc}
\usepackage{listings} 

\usetheme{Pradita}

\subtitle{IF140303-Web Application Development}

\title{Session-08:\\
\Huge{
Phoenix Framework:\\List \& Add\\
\vspace{-15pt}
}
}
\date[Serial]{\scriptsize{PRU/SPMI/FR-BM-18/0222}}
\author[Pradita]{\small{\textbf{Alfa Yohannis}}}

\lstdefinelanguage{Elixir} {
	keywords={def, defmodule, do, end, for, if, else, true, false, scope},
	language=ruby,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={@spec, @moduledoc, iex, Enum, @doc, add, alter, field, has_many, timestamps},
	ndkeywordstyle=\color{purple}\bfseries,
	sensitive=true,
	commentstyle=\color{gray},
	stringstyle=\color{red},
	numbers=left,
	numberstyle=\tiny\color{gray},
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{lightgray!10},
	tabsize=2,
	comment=[l]{\#},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{gray}\ttfamily,
	stringstyle=\color{purple}\ttfamily,
	showstringspaces=false
}


\lstdefinelanguage{bash} {
	keywords={},
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={iex},
	ndkeywordstyle=\color{purple}\bfseries,
	sensitive=true,
	commentstyle=\color{gray},
	stringstyle=\color{red},
	numbers=left,
	numberstyle=\tiny\color{gray},
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{lightgray!10},
	tabsize=2,
	comment=[l]{\#},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{gray}\ttfamily,
	stringstyle=\color{purple}\ttfamily,
	showstringspaces=false
}

\lstdefinelanguage{heex} {
	keywords={h1, b, a, href, class, for},
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={p, else, if, do, end},
	ndkeywordstyle=\color{purple}\bfseries,
	sensitive=true,
	commentstyle=\color{gray},
	stringstyle=\color{red},
	numbers=left,
	numberstyle=\tiny\color{gray},
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{lightgray!10},
	commentstyle=\color{gray}\ttfamily,
	stringstyle=\color{purple}\ttfamily,
	morecomment=[s]{<!--}{-->},
	string=[s]{'}{'},
	morestring=[s]{"}{"},
	tabsize=2
}

\begin{document}
	
	\frame{\titlepage}
	
		\begin{frame}[fragile]
		\frametitle{Contents}
		\vspace{20pt}
		\begin{columns}[t]
			\column{0.5\textwidth}
			\tableofcontents[sections={1-6}]
			
			\column{0.5\textwidth}
			\tableofcontents[sections={7-99}]
		\end{columns}
	\end{frame}

\section{Introduction}

\begin{frame}[fragile]{Introduction}
\vspace{10pt}

\begin{itemize}
  \item \textbf{Hiwi} is a \textbf{Queue Management System} built with the \textbf{Phoenix Framework} in \textbf{Elixir}.
  \item Queue systems are common in hospitals, banks, and service offices.
  \item Phoenix offers:
    \begin{itemize}
      \item High performance and scalability
      \item Real-time features via \texttt{Channels} and \texttt{PubSub}
      \item Integration with \textbf{Ecto} for database and validation
    \end{itemize}
  \item This session focuses on building models, controllers, and views to manage data through the web interface.
	\item It demonstrates how to add and list data in an MVC-based web application.
  
\end{itemize}

\end{frame}

\section{Creating a New Project}

%-----------------------------------------------
\begin{frame}[fragile]{Creating a New Phoenix Project (Part 1)}
\vspace{20pt}

Prepare the Elixir package manager to install dependencies:


\begin{lstlisting}[language=bash]
mix local.hex
\end{lstlisting}


 Install the Phoenix project generator archive:


\begin{lstlisting}[language=bash]
mix archive.install hex phx_new
\end{lstlisting}

Create a new project named \texttt{hiwi}  
  and confirm with \texttt{Y} when prompted:


\begin{lstlisting}[language=bash]
mix phx.new hiwi
\end{lstlisting}

Enter the project directory:

\begin{lstlisting}[language=bash]
cd hiwi
\end{lstlisting}

\end{frame}

%-----------------------------------------------
\begin{frame}[fragile]{Creating a New Phoenix Project (Part 2)}
\vspace{20pt}

Fetch all declared dependencies:


\begin{lstlisting}[language=bash]
mix deps.get
\end{lstlisting}

Default structure generated by Phoenix:


\begin{lstlisting}[language=bash]
lib/hiwi/         # Core modules and logic
lib/hiwi_web/     # Controllers, views, templates (.heex)
config/           # Environment settings
assets/           # Frontend (JS, CSS)
\end{lstlisting}

Phoenix cleanly separates business logic from the web interface.
 Next steps:
    \begin{itemize}
      \item Configure PostgreSQL connection.
      \item Create the \texttt{queues} migration.
      \item Build controller and view for Add \& List.
    \end{itemize}

\end{frame}

\section{Database Configuration}

%-----------------------------------------------
\begin{frame}[fragile]{Configuring the Database (Part 1)}
\vspace{10pt}

\begin{columns}[T]
  \begin{column}{0.5\textwidth}
    Database connection for development in \texttt{config/dev.exs}. 
    \textbf{Ecto} is the data access layer, and each app  
    includes a \texttt{Repo} module (here: \texttt{Hiwi.Repo}).  
    Ensure the repo is registered in 
    \texttt{:ecto\_repos} in \texttt{config/config.exs}:
    
    \vspace{5pt}
    \begin{lstlisting}[language=Elixir]
# config/config.exs
import Config

config :hiwi,
  ecto_repos: [Hiwi.Repo]
    \end{lstlisting}
  \end{column}

  \begin{column}{0.45\textwidth}
    Development credentials are in  
    \texttt{config/dev.exs}.

    \vspace{5pt}
    \begin{lstlisting}[language=Elixir]
# config/dev.exs
import Config

config :hiwi, Hiwi.Repo,
  username: "postgres",
  password: "1234",
  hostname: "localhost",
  database: "hiwi_dev",
  ...
    \end{lstlisting}
  \end{column}
\end{columns}

\end{frame}


%-----------------------------------------------
\begin{frame}[fragile]{Configuring the Database (Part 2)}
\vspace{10pt}

\begin{columns}
  %-----------------------------------------------
  \begin{column}[T]{0.47\textwidth}
    Phoenix automatically generates  
    \texttt{lib/hiwi/repo.ex}, defining the repository  
    module and its PostgreSQL adapter:

    \begin{lstlisting}[language=Elixir]
# lib/hiwi/repo.ex
defmodule Hiwi.Repo do
  use Ecto.Repo,
    otp_app: :hiwi,
    adapter: Ecto.Adapters.Postgres
end
    \end{lstlisting}

    To create the database, run:

  \end{column}
  %-----------------------------------------------
  \begin{column}[T]{0.47\textwidth}
    \begin{lstlisting}[language=bash]
mix ecto.create
    \end{lstlisting}
    Start the Phoenix server with either command:
    \begin{lstlisting}[language=bash]
mix phx.server
iex -S mix phx.server
    \end{lstlisting}

    Then open your browser and visit:
    \begin{lstlisting}[language=bash]
http://localhost:4000
    \end{lstlisting}

    If the Phoenix welcome page appears,  
    the database connection and web server  
    are working correctly.
  \end{column}
  %-----------------------------------------------
\end{columns}

\end{frame}
%-----------------------------------------------



\section{Migrations}

%-----------------------------------------------
\begin{frame}[fragile]{Database Migrations (Part 1)}
\vspace{10pt}

After configuring the database, the next step is to create the table used by the application.  
In the Hiwi project, the main table is \texttt{queues}, managed using Ecto’s migration mechanism.  
Migrations act like version control for databases — each change to the schema is tracked  
in a timestamped file, allowing rollback if needed.

To generate a migration file:

\begin{lstlisting}[language=bash]
mix ecto.gen.migration create_queues
\end{lstlisting}

This command creates a new file under \texttt{priv/repo/migrations/} with a timestamped name, e.g.:

\begin{lstlisting}[language=bash]
priv/repo/migrations/20251102090627_create_queues.exs
\end{lstlisting}

Open the file and define the structure of the \texttt{queues} table.

\end{frame}

%-----------------------------------------------
%-----------------------------------------------
\begin{frame}[fragile]{Database Migrations (Part 2a)}
\vspace{10pt}

\begin{lstlisting}[language=Elixir, basicstyle=\ttfamily\scriptsize]
defmodule Hiwi.Repo.Migrations.CreateQueues do
  use Ecto.Migration

  def down do
    drop_if_exists table(:queues)
  end

  def change do
    drop_if_exists table(:queues)

    create table(:queues) do
      add :name, :string, null: false
      add :description, :text
      add :status, :string, null: false
\end{lstlisting}

\vspace{5pt}
The migration begins by defining the module and two functions:  
\texttt{change/0} for creating the table and \texttt{down/0} for rollback.  
It ensures the old table is dropped before creating a new one.

\end{frame}

%-----------------------------------------------
\begin{frame}[fragile]{Database Migrations (Part 2b)}
\vspace{10pt}

\begin{lstlisting}[language=Elixir, basicstyle=\ttfamily\scriptsize]
      add :prefix, :string, null: false, default: "A"
      add :max_number, :integer, null: false, default: 100
      add :current_number, :integer, null: false, default: 1
      add :create_user, :string
      add :update_user, :string
      timestamps(type: :utc_datetime)
    end
  end
end
\end{lstlisting}

\vspace{5pt}
\textbf{Highlights:}  
The \texttt{name} and \texttt{status} columns are mandatory, defining the queue’s identity and state.  
\texttt{prefix} sets the numbering prefix (default “A”), while \texttt{max\_number} and \texttt{current\_number} control ticket range.  
\texttt{create\_user} and \texttt{update\_user} record user actions, and  
\texttt{timestamps(type: :utc\_datetime)} automatically adds UTC audit columns.  
Finally, \texttt{down/0} allows safe rollback if needed.

\end{frame}
%-----------------------------------------------

%-----------------------------------------------


%-----------------------------------------------
\begin{frame}[fragile]{Database Migrations (Part 3)}
\vspace{10pt}

Apply the migration to update the database schema:

\begin{lstlisting}[language=bash]
mix ecto.migrate
\end{lstlisting}

Ecto executes all pending migrations in timestamp order.  
If successful, the \texttt{queues} table will appear in \texttt{hiwi\_dev} with the defined columns.

Verify the result using PostgreSQL or pgAdmin:

\begin{lstlisting}[language=bash]
\d queues
\end{lstlisting}

If all columns and types match, the migration succeeded.  
Next, define the \texttt{Queue} schema model in Elixir so Phoenix  
can interact with this table through Ecto queries.

\end{frame}
%-----------------------------------------------

\section{Model}

%-----------------------------------------------
\begin{frame}[fragile]{Defining the Model (Part 1)}
\vspace{10pt}

After creating the \texttt{queues} table, the next step is to define  
the \textbf{model} (\textbf{schema}) that represents it in Elixir.  
The model provides a structured, declarative way to interact with  
database rows as Elixir structs instead of raw SQL.

Use the Phoenix generator to create the base schema:

\begin{lstlisting}[language=bash]
mix phx.gen.schema Queue queues
\end{lstlisting}

This command generates the file \texttt{lib/hiwi/queue.ex}.  
You can now open and customize it to match the table structure.

\end{frame}
%-----------------------------------------------

\begin{frame}[fragile]{Defining the Model (Part 2a)}
\vspace{20pt}

The schema section maps database columns to Elixir fields.  
Each \texttt{field} corresponds to a column in the \texttt{queues} table.

\begin{lstlisting}[language=Elixir, basicstyle=\ttfamily\scriptsize]
defmodule Hiwi.Queue do
  use Ecto.Schema
  import Ecto.Changeset

  schema "queues" do
    field :name, :string
    field :status, :string
    field :description, :string
    field :prefix, :string
    field :max_number, :integer
    field :current_number, :integer
    field :create_user, :string
    field :update_user, :string

    timestamps(type: :utc_datetime)
  end
\end{lstlisting}

\end{frame}
%-----------------------------------------------

\begin{frame}[fragile]{Defining the Model (Part 2b)}
\vspace{10pt}

The \texttt{changeset/2} function validates and casts input data  
before saving it to the database. It ensures that required fields  
(\texttt{name}, \texttt{prefix}, and \texttt{max\_number}) are always present.

\begin{lstlisting}[language=Elixir, basicstyle=\ttfamily\scriptsize]
  @doc false
  def changeset(queue, attrs) do
    queue
    |> cast(attrs, [
      :name, :description, :status, :prefix,
      :max_number, :current_number,
      :create_user, :update_user
    ])
    |> validate_required([:name, :prefix, :max_number])
  end
end
\end{lstlisting}

\end{frame}
%-----------------------------------------------

%-----------------------------------------------
\begin{frame}[fragile]{Defining the Model (Part 3)}
\vspace{10pt}

\begin{columns}[T]
  % Left column: code
  \begin{column}{0.52\textwidth}
\begin{lstlisting}[language=Elixir]
alias Hiwi.{Repo, Queue}

Repo.insert(%Queue{
  name: "Loket A",
  status: "ready",
  prefix: "A",
  max_number: 100,
  current_number: 1,
  create_user: "admin"
})
\end{lstlisting}
Once the schema and validations are ready,  
the model can be used to perform CRUD operations through Ecto.
  \end{column}

  % Right column: explanation
  \begin{column}{0.43\textwidth}


The example inserts a new record into the \texttt{queues} table  
directly from the IEx console. Ecto automatically generates  
the corresponding SQL statement and executes it safely  
through the repository module \texttt{Hiwi.Repo}.\\  

This demonstrates how Phoenix bridges application logic  
and persistent data using the model layer.
  \end{column}
\end{columns}

\end{frame}
%-----------------------------------------------

%-----------------------------------------------
\section{Controller}

%-----------------------------------------------
\begin{frame}[fragile]{Controller Overview (Part 1)}
\vspace{10pt}

In Phoenix, a \textbf{controller} connects application logic with the user interface.  
It receives requests via the router, processes data (often through models),  
and passes results to the view layer for rendering.  

For Hiwi, the main controller module is \texttt{HiwiWeb.QueueController},  
located in \texttt{lib/hiwi\_web/controllers/}.  

\begin{lstlisting}[language=Elixir]
# lib/hiwi_web/controllers/queue_controller.ex
defmodule HiwiWeb.QueueController do
  use HiwiWeb, :controller
  alias Hiwi.Queue
  alias Hiwi.Repo
\end{lstlisting}

The \texttt{use HiwiWeb, :controller} macro loads Phoenix’s controller features,  
while \texttt{alias} statements simplify module references.  

\end{frame}
%-----------------------------------------------

\begin{frame}[fragile]{Controller Functions (Part 2a)}
\vspace{10pt}

\begin{lstlisting}[language=Elixir, basicstyle=\ttfamily\scriptsize]
  def index(conn, _params) do
    queues = Repo.all(Queue)
    render(conn, :index, queues: queues)
  end

  def new(conn, _params) do
    changeset = Queue.changeset(%Queue{}, %{})
    render(conn, :new, changeset: changeset)
  end
\end{lstlisting}

\begin{itemize}
  \item \texttt{index/2} retrieves all queue records  
  and renders them in \texttt{index.html.heex}.
  \item \texttt{new/2} prepares an empty \textbf{changeset} for the form view.
  \item A \texttt{changeset} tracks data changes, validates fields, enforces rules,  
  and stores errors — ensuring only valid data is saved.
  \item \texttt{Queue.changeset(\%Queue\{\}, \%\{\})}  
  creates a blank changeset for a new record.
\end{itemize}




\end{frame}

%-----------------------------------------------

\begin{frame}[fragile]{Controller Functions (Part 2b)}
\vspace{10pt}

\begin{lstlisting}[language=Elixir, basicstyle=\ttfamily\scriptsize]
  def create(conn, params) do
    %{"queue" => queue_params} = params
    changeset = Queue.changeset(%Queue{}, queue_params)

    case Repo.insert(changeset) do
      {:ok, _queue} ->
        conn
        |> put_flash(:info, "Queue created successfully.")
        |> redirect(to: "/")

      {:error, changeset} ->
        IO.inspect(changeset)
        render(conn, :new, changeset: changeset)
    end
  end
end
\end{lstlisting}

\texttt{create/2} handles form submission, validating input  
and inserting new data into the database.  
On success, the user is redirected with a confirmation message.

\end{frame}
%-----------------------------------------------

\begin{frame}[fragile]{Controller Summary (Part 3)}
\vspace{10pt}

The \texttt{QueueController} serves as the bridge between the database  
and the browser interface.  

\begin{itemize}
  \item \textbf{index/2:} Displays all queues.
  \item \textbf{new/2:} Shows a blank form for adding a queue.
  \item \textbf{create/2:} Validates and saves form input.
\end{itemize}

Controllers in Phoenix focus on high-level request handling —  
data retrieval, storage, and navigation —  
while the actual HTML output is managed by the view layer.  

In the next step, this controller connects with  
\texttt{index.html.heex} and \texttt{new.html.heex}  
to display queue listings and input forms.

\end{frame}
%-----------------------------------------------

\section{View}

%-----------------------------------------------
\begin{frame}[fragile]{View Layer Overview (Part 1)}
\vspace{15pt}

Views usually consist of an Elixir module  
that connects templates written in HEEx (HTML + Embedded Elixir). For the queue module, the view is defined in  
\texttt{lib/hiwi\_web/controllers/queue\_html.ex}:  

\begin{lstlisting}[language=Elixir, basicstyle=\ttfamily\scriptsize]
# lib/hiwi_web/controllers/queue_html.ex
defmodule HiwiWeb.QueueHTML do
  @moduledoc """
  Contains HTML templates used by QueueController.
  Templates are located in `queue_html/`.
  """
  use HiwiWeb, :html

  embed_templates "queue_html/*"
end
\end{lstlisting}

\texttt{use HiwiWeb, :html} provides Phoenix HTML rendering functions,  
while \texttt{embed\_templates "queue\_html/*"} automatically loads  
all HEEx templates under that directory.  

\end{frame}
%-----------------------------------------------

\begin{frame}[fragile]{Queue Index Template (Part 2)}
\vspace{20pt}

The \texttt{index.html.heex} template displays all queue entries  
retrieved from the controller via \texttt{@queues}. Each list item shows the queue name and action links for  
\textit{Edit} and \textit{Delete}.  
The \texttt{<.link>} component automatically handles routing and  
HTTP methods, while the “New Queue” button links to the creation form.    

\begin{lstlisting}[language=heex, basicstyle=\ttfamily\tiny]
<h1>Queuex</h1>
<ul>
  <%= for queue <- @queues do %>
    <li class="action-links"> 
      <div><%= queue.name %></div>
      <div>
        |
        <.link href={~p"/queues/edit/#{queue.id}"}>Edit</.link> |
        <.link href={~p"/queues/delete/#{queue.id}"} method="delete">Delete</.link> |
      </div>
    </li>
  <% end %>
</ul>

<div class="button">
  <.link href={~p"/queues/new"}>New Queue</.link>
</div>
\end{lstlisting}



\end{frame}
%-----------------------------------------------

\begin{frame}[fragile]{New Queue Form Template (Part 3)}
\vspace{20pt}

The \texttt{new.html.heex} template displays a form linked to \texttt{@changeset} from the controller, automatically showing validation errors.
Built-in components \texttt{<.input>} and \texttt{<.button>} integrate with Ecto for simpler form handling, posting data to \texttt{/queues} where \texttt{create/2} validates and inserts records.


\begin{lstlisting}[language=heex, basicstyle=\ttfamily\tiny]
<h1>New Queue</h1>
<.form :let={f} for={@changeset} action={~p"/queues"}>
  <div>
    <label for="name">Name</label>
    <.input field={f[:name]} />
    <label for="status">Status</label>
    <.input field={f[:status]} type="select"
      options={["Ready": "ready", "Running": "running", "Inactive": "inactive"]} />
    <label for="description">Description</label>
    <.input field={f[:description]} type="textarea" />
    <label for="prefix">Prefix</label>
    <.input field={f[:prefix]} />
    <label for="max_number">Max Number</label>
    <.input field={f[:max_number]} type="number" />
    <div class="vertical-space"></div>
    <.button class="button">Submit</.button>
  </div>
</.form>
\end{lstlisting}


\end{frame}
%-----------------------------------------------

\section{Import, Alias, Use}

%-----------------------------------------------
\begin{frame}[fragile]{Understanding \texttt{use}}
\vspace{10pt}

In Elixir, the keyword \texttt{use} imports predefined behavior or macros  
from another module, often providing shared functionality like rendering  
or routing.  

\begin{lstlisting}[language=Elixir]
defmodule HiwiWeb.QueueController do
  use HiwiWeb, :controller
  ...
end
\end{lstlisting}

This line invokes the macro from \texttt{HiwiWeb}, automatically  
adding Phoenix controller features such as \texttt{render/3},  
\texttt{redirect/2}, and \texttt{put\_flash/3}.  

A similar declaration appears in the view module:  

\begin{lstlisting}[language=Elixir]
use HiwiWeb, :html
\end{lstlisting}

This enables HEEx rendering and components like  
\texttt{<.form>} and \texttt{<.link>} within templates.

\end{frame}

\begin{frame}[fragile]{Comparing \texttt{use} vs. \texttt{extends/inherits}}
\vspace{10pt}

\begin{itemize}
  \item In object-oriented languages, \texttt{extends} or inheritance copies methods and properties from a parent class to a child class at compile time.
  \item In Elixir, \texttt{use} does not create a class hierarchy--it \textbf{executes a macro} from another module, injecting functions, aliases, and imports dynamically.
  \item While inheritance shares behavior through class structure, \texttt{use} shares behavior through \textbf{metaprogramming and composition}.
  \item Example: \texttt{use HiwiWeb, :controller} expands into predefined Phoenix functions like \texttt{render/3} and \texttt{redirect/2}, without forming a parent-child relationship.
  \item Thus, \texttt{use} in Elixir is conceptually similar to \texttt{extends}, but implemented via macros for flexible and explicit code reuse.
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Understanding Macros in Elixir}
\vspace{10pt}

\begin{itemize}
  \item A \textbf{macro} runs at \textbf{compile time} to generate code dynamically before execution.
  \item It enables \textbf{metaprogramming} — writing code that writes other code.
  \item When a module \texttt{use}s another, it usually triggers that module’s \texttt{\_\_using\_\_/1} macro, injecting functions, aliases, and imports.
  \item Example:
\begin{lstlisting}[language=Elixir, basicstyle=\ttfamily\scriptsize]
defmacro __using__(_opts) do
  quote do
    import MyHelpers
    def hello, do: IO.puts("Hello from macro!")
  end
end
\end{lstlisting}
  \item Macros make Elixir extensible — core libraries like Phoenix and Ecto use them to provide clean, reusable patterns.
\end{itemize}

\end{frame}


%-----------------------------------------------

\begin{frame}[fragile]{Understanding \texttt{alias}}
\vspace{10pt}

The \texttt{alias} keyword shortens long module names to make  
the code cleaner and easier to read.  

Without aliasing:
\begin{lstlisting}[language=Elixir]
Hiwi.Repo.all(Hiwi.Queue)
\end{lstlisting}

Using aliases:
\begin{lstlisting}[language=Elixir]
alias Hiwi.Queue
alias Hiwi.Repo
\end{lstlisting}

After defining these aliases, you can simply call:  
\texttt{Repo.all(Queue)} instead of typing full module names.  
This improves readability, reduces repetition, and clarifies intent  
within Phoenix controllers and contexts.

\end{frame}
%-----------------------------------------------

\begin{frame}[fragile]{Understanding \texttt{import}}
\vspace{20pt}

The \texttt{import} keyword brings functions from another module  
into the current scope, allowing them to be called directly.  

Example from the model:
\begin{lstlisting}[language=Elixir]
defmodule Hiwi.Queue do
  use Ecto.Schema
  import Ecto.Changeset
  ...
end
\end{lstlisting}

This allows calling \texttt{cast(...)} and \texttt{validate\_required(...)}  
without prefixing them with \texttt{Ecto.Changeset}.  
Use \texttt{import} when frequently reusing several functions  
from a specific module.  

\vspace{4pt}
\textbf{Summary:} \texttt{\textbf{use}} $\rightarrow$ includes shared behavior or macros. \texttt{\textbf{alias}} $\rightarrow$ creates short names for modules. \texttt{\textbf{import}} $\rightarrow$ brings functions for direct use.

\end{frame}
%-----------------------------------------------

\section{Summary}

\begin{frame}[fragile]{Summary}
\vspace{10pt}

\begin{itemize}
  \item This chapter covered the creation of the \texttt{Queue} module in the \texttt{Hiwi} application using Phoenix Framework and Ecto.
  \item Steps included creating a new project, configuring PostgreSQL connections, and building the \texttt{queues} table migration.
  \item A model (schema) was defined to represent the table structure in Elixir code.
  \item Controllers and Views were implemented to manage data flow from the database to the web interface.
  \item The \textit{Add} and \textit{List} features demonstrated the practical use of the Model--View--Controller (MVC) pattern in Phoenix.
  \item This foundation prepares readers to extend the system with \texttt{get}, \texttt{update}, and \texttt{delete} functions, completing full CRUD operations.
\end{itemize}

\end{frame}

\end{document}
