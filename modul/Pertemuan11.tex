\chapter{Plugs untuk Autentikasi dan Otorisasi Pengguna}

\section{Pendahuluan}
Bab ini menjelaskan penggunaan \textit{plugs} dalam framework Phoenix untuk menangani autentikasi dan otorisasi pengguna. Dalam aplikasi Phoenix, plugs digunakan pada router, endpoint, dan controller untuk memproses permintaan, membaca sesi, memuat pengguna yang sedang login, serta memastikan bahwa hanya pengguna yang berhak dapat mengakses suatu resource. Pada modul ini, fokus utamanya adalah bagaimana plug digunakan untuk menetapkan \texttt{@current\_user} dan bagaimana hal tersebut terhubung dengan struktur database yang mendukung kepemilikan data.

\section{Membangun Asosiasi Database dengan Ecto}
Agar antrean (\texttt{queues}) dapat terhubung dengan pengguna, diperlukan relasi antara skema \texttt{User} dan \texttt{Queue}. Dengan adanya relasi ini, setiap antrean dapat memiliki seorang pemilik. Relasi tersebut menjadi dasar penerapan logika otorisasi, misalnya memastikan bahwa pengguna hanya dapat mengubah antrean yang mereka miliki.

\subsection{Membuat Migrasi untuk Menambahkan \texttt{user\_id} ke Tabel \texttt{queues}}
Langkah pertama adalah menambahkan kolom \texttt{user\_id} ke dalam tabel \texttt{queues}. Kolom ini berfungsi sebagai kunci asing yang merujuk pada tabel \texttt{users} dan menandakan siapa pemilik dari antrean tersebut.

\begin{lstlisting}[language=bash, caption={Membuat migrasi \texttt{add\_user\_id\_to\_queues}.}]
mix ecto.gen.migration add_user_id_to_queues
\end{lstlisting}

Isi migrasi:

\begin{lstlisting}[language=Elixir, caption={Menambahkan kolom \texttt{user\_id} pada tabel \texttt{queues}.}]
defmodule Hiwi.Repo.Migrations.AddUserIdToQueues do
  use Ecto.Migration

  def change do
    alter table(:queues) do
      add :user_id, references(:users)
    end
  end
end
\end{lstlisting}

Menjalankan migrasi:

\begin{lstlisting}[language=bash, caption={Menjalankan migrasi.}]
mix ecto.migrate
\end{lstlisting}

Bagian migrasi ini melakukan tiga hal. Pertama, deklarasi \texttt{use Ecto.Migration} menandakan bahwa modul tersebut merupakan modul migrasi. Kedua, perintah \texttt{alter table(:queues)} menunjukkan bahwa perubahan dilakukan pada tabel \texttt{queues}. Ketiga, baris \texttt{add :user\_id, references(:users)} menambahkan kolom baru bertipe referensi ke tabel \texttt{users}, sehingga setiap antrean dapat dikaitkan dengan pengguna tertentu sebagai pemiliknya.

Setelah migrasi dijalankan, tabel \texttt{queues} telah memiliki kolom \texttt{user\_id}. Kolom ini memungkinkan aplikasi menentukan antrean mana yang dimiliki oleh pengguna yang sedang login dan menjadi dasar untuk plug otorisasi yang memastikan hanya pemilik antrean yang dapat melakukan operasi tertentu.


\subsection{Memodifikasi Skema \texttt{User}}
Skema \texttt{User} perlu diperbarui agar dapat terhubung dengan antrean yang dimiliki oleh pengguna. Relasi ini didefinisikan dengan menambahkan \texttt{has\_many} pada skema, sehingga setiap pengguna memiliki akses langsung ke daftar antrean yang ia miliki.

\begin{lstlisting}[language=Elixir, caption={\texttt{lib/hiwi/user.ex}}]
schema "users" do
  field :email, :string
  ...
  has_many :queues, Hiwi.Queue
  ...
end
\end{lstlisting}

Bagian \texttt{schema "users"} mendefinisikan struktur data untuk tabel \texttt{users}, sedangkan baris \texttt{has\_many :queues, Hiwi.Queue} menambahkan relasi one-to-many antara pengguna dan antrean. Dengan relasi ini, aplikasi dapat memuat seluruh antrean yang dimiliki oleh pengguna tanpa harus menulis relasi secara manual dalam query. Skema \texttt{User} kini dapat merujuk pada semua antrean yang terhubung melalui kolom \texttt{user\_id} pada tabel \texttt{queues}.

\subsection{Memodifikasi Skema \texttt{Queue}}
Untuk melengkapi relasi tersebut, skema \texttt{Queue} perlu mencakup informasi mengenai pemilik antrean. Hal ini dilakukan dengan menambahkan \texttt{belongs\_to} yang menghubungkan setiap antrean dengan satu pengguna. Relasi ini selaras dengan kolom \texttt{user\_id} yang telah ditambahkan melalui migrasi sebelumnya.

\begin{lstlisting}[language=Elixir, caption={\texttt{lib/hiwi/queue.ex}}]
schema "queues" do
  field :name, :string
  ...
  belongs_to :user, Hiwi.User
  ...
end
\end{lstlisting}

Bagian \texttt{schema "queues"} mendefinisikan struktur untuk tabel \texttt{queues}. Baris \texttt{belongs\_to :user, Hiwi.User} menyatakan bahwa setiap antrean dimiliki oleh satu pengguna. Relasi ini memanfaatkan kolom \texttt{user\_id} sebagai kunci asing yang menghubungkan antrean dengan pemiliknya.

\subsubsection{Keuntungan dari Asosiasi One-to-Many antara \texttt{User} dan \texttt{Queue}}
Asosiasi antara \texttt{User} dan \texttt{Queue} membawa beberapa keuntungan penting. Pertama, akses data menjadi lebih mudah karena setiap pengguna dapat mengambil antrean miliknya melalui relasi yang sudah didefinisikan pada skema. Kedua, integritas data tetap terjaga karena referensi antara pengguna dan antrean disimpan secara konsisten melalui kunci asing. Ketiga, kueri yang membutuhkan informasi kepemilikan antrean dapat dilakukan dengan lebih efisien karena Ecto sudah mengetahui relasi antara kedua entitas tersebut.

Asosiasi ini menjadi fondasi penting bagi fitur-fitur aplikasi yang melibatkan pengelolaan antrean berdasarkan pengguna, serta memastikan bahwa setiap antrean terhubung dengan pemilik yang benar.


\section{Plugs}

\subsection{Definisi Plugs}
\texttt{Plugs} merupakan komponen dasar dalam Phoenix yang berfungsi memproses permintaan (request) dan respons (response) HTTP. Phoenix menggunakan \texttt{plugs} sebagai middleware yang dapat disisipkan ke berbagai tahap alur permintaan untuk menangani tugas seperti autentikasi, otorisasi, logging, manajemen sesi, hingga modifikasi data sebelum diteruskan ke tahap berikutnya.

Setiap \texttt{plug} menerima objek \texttt{conn}, yaitu struktur yang mewakili seluruh konteks permintaan HTTP yang sedang diproses. Plug dapat membaca atau memodifikasi nilai di dalam \texttt{conn}, misalnya menambah nilai ke \texttt{conn.assigns}, memeriksa sesi, atau menghentikan alur permintaan. Phoenix menyediakan tiga lokasi utama untuk menerapkan \texttt{plugs}: pada endpoint, pada router, dan pada controller. Ketiganya memungkinkan pengaturan plug sesuai kebutuhan, dari pengaturan global hingga spesifik pada aksi tertentu.

Sebuah \texttt{plug} ditulis sebagai modul Elixir dengan dua fungsi utama. Fungsi \texttt{init/1} dipanggil sekali saat aplikasi dijalankan untuk menginisialisasi konfigurasi. Nilai yang dikembalikan oleh \texttt{init/1} kemudian diteruskan ke fungsi \texttt{call/2} setiap kali permintaan masuk. Fungsi \texttt{call/2} adalah tempat logika utama plug dijalankan, seperti memverifikasi sesi pengguna atau menghentikan permintaan jika kondisi tertentu tidak terpenuhi.

Berikut contoh implementasi plug sederhana:

\begin{lstlisting}[language=Elixir, caption={Contoh Implementasi Plug Sederhana}]
defmodule MyAppWeb.Plugs.CheckAuth do
  import Plug.Conn

  def init(default), do: default
  
  def call(conn, _opts) do
    if get_session(conn, :user_id) do
      conn
    else
      conn
      |> put_flash(:error, "Autentikasi diperlukan.")
      |> redirect(to: "/login")
      |> halt()
    end
  end
end
\end{lstlisting}

Pada contoh tersebut, plug \texttt{CheckAuth} memeriksa apakah sesi mengandung \texttt{:user\_id}. Jika tidak ada, pengguna diarahkan ke halaman login dan alur permintaan dihentikan dengan \texttt{halt()}. Dengan mekanisme seperti ini, Phoenix memungkinkan pengaturan alur permintaan yang lebih terstruktur dan mudah dikontrol.

\subsection{Membuat Plug \texttt{SetUser}}
Plug \texttt{SetUser} digunakan untuk memuat pengguna yang sedang login dan menyimpannya ke dalam \texttt{conn.assigns}. Dengan memanfaatkan \texttt{user\_id} yang tersimpan di sesi, plug ini mengambil data pengguna dari database dan menjadikannya tersedia untuk seluruh permintaan selama sesi tersebut berlangsung. Hal ini sangat penting untuk fitur yang memerlukan informasi mengenai pengguna saat ini, seperti otorisasi atau penyesuaian tampilan antarmuka.

\begin{lstlisting}[language=Elixir, caption={\texttt{lib/hiwi\_web/plugs/set\_user.ex}}]
defmodule HiwiWeb.Plugs.SetUser do
  import Plug.Conn

  alias Hiwi.Repo
  alias Hiwi.User

  def init(_params) do
  end

  def call(conn, _params) do
    user_id = get_session(conn, :user_id)

    cond do
      user = user_id && Repo.get(User, user_id) ->
        assign(conn, :user, user)
      true ->
        assign(conn, :user, nil)
    end
  end
end
\end{lstlisting}

Modul \texttt{SetUser} berada dalam namespace \texttt{HiwiWeb.Plugs} dan mengimpor fungsi-fungsi dari \texttt{Plug.Conn} untuk membaca sesi serta menetapkan nilai pada \texttt{conn.assigns}. Modul ini juga menggunakan \texttt{Hiwi.Repo} dan skema \texttt{Hiwi.User} untuk melakukan query ke database. Fungsi \texttt{init/1} tidak memerlukan konfigurasi, sehingga cukup dibiarkan tanpa nilai kembalian.

Logika utama berada pada fungsi \texttt{call/2}. Fungsi ini mengambil \texttt{user\_id} dari sesi. Jika nilai tersebut ada, plug mencoba memuat pengguna terkait dari database menggunakan \texttt{Repo.get/2}. Ketika pengguna valid ditemukan, hasilnya disimpan di dalam \texttt{conn.assigns} menggunakan \texttt{assign/3}. Jika \texttt{user\_id} tidak ada atau pengguna tidak ditemukan, nilai \texttt{nil} diberikan sebagai pengganti.

Plug ini memastikan bahwa setiap permintaan HTTP memiliki informasi pengguna yang akurat. Dengan demikian, controller, view, maupun komponen lain dapat mengakses \texttt{@user} tanpa perlu melakukan query ulang secara eksplisit, sehingga alur aplikasi menjadi lebih efisien dan konsisten.

\subsubsection{Manfaat Menggunakan Plug \texttt{SetUser}}
Dengan menetapkan \texttt{user} ke dalam \texttt{conn.assigns}, terdapat beberapa manfaat sebagai berikut:
\begin{itemize}
	\item \textbf{Efisiensi}: Data pengguna hanya diambil sekali per permintaan, sehingga mengurangi permintaan yang tidak perlu ke database.
	\item \textbf{Kemudahan Akses}: Controller dan komponen lainnya dapat mengakses data pengguna dengan mudah melalui \texttt{@user}.
	\item \textbf{Keamanan}: Dengan memverifikasi data pengguna pada setiap permintaan, plug memastikan bahwa data yang digunakan hanya berasal dari pengguna yang terautentikasi, sehingga mencegah akses yang tidak sah.
\end{itemize}


\subsection{Membuat Plug \texttt{RequireAuth}}
Plug \texttt{RequireAuth} digunakan untuk memastikan bahwa hanya pengguna yang telah login yang dapat mengakses tindakan atau halaman tertentu. Plug ini melakukan pengecekan sederhana terhadap nilai pengguna yang telah disimpan dalam \texttt{conn.assigns} oleh plug sebelumnya, seperti \texttt{SetUser}. Jika tidak ada pengguna yang ditemukan, permintaan tidak diteruskan dan koneksi akan diarahkan ke halaman utama dengan pesan flash yang sesuai.

\begin{lstlisting}[language=Elixir, caption={\texttt{lib/hiwi\_web/plugs/require\_auth.ex}}]
defmodule HiwiWeb.Plugs.RequireAuth do
  import Plug.Conn
  import Phoenix.Controller

  def init(_params) do
  end

  def call(conn, _params) do
    if conn.assigns[:user] do
      conn
    else
      conn
      |> put_flash(:error, "You haven't signed in.")
      |> redirect(to: "/")
      |> halt()
    end
  end
end
\end{lstlisting}

Modul \texttt{RequireAuth} berada dalam namespace \texttt{HiwiWeb.Plugs}. Modul ini mengimpor fungsi dari \texttt{Plug.Conn} untuk menambah pesan flash, menghentikan alur permintaan, dan melakukan manipulasi koneksi lainnya. Selain itu, \texttt{Phoenix.Controller} diimpor untuk menyediakan fungsi \texttt{redirect/2}. Fungsi \texttt{init/1} tidak memerlukan konfigurasi dan dibiarkan kosong.

Fungsi utama plug ini adalah \texttt{call/2}. Fungsi ini memeriksa apakah nilai pengguna telah tersedia dalam \texttt{conn.assigns}. Jika pengguna ditemukan, permintaan dilanjutkan sebagaimana mestinya. Jika tidak ada pengguna, plug menambahkan pesan kesalahan, mengarahkan koneksi ke halaman utama, dan menghentikan pemrosesan lebih lanjut menggunakan \texttt{halt/1}. Dengan alur ini, hanya permintaan dari pengguna terautentikasi yang dapat diteruskan ke tindakan atau controller yang memerlukan autentikasi.

\subsubsection{Fungsi Utama Plug \texttt{RequireAuth}}
Plug \texttt{RequireAuth} berfungsi sebagai mekanisme pengaman yang memblokir akses ke halaman atau tindakan yang memerlukan autentikasi. Plug ini memanfaatkan informasi pengguna yang telah dimuat sebelumnya, memastikan bahwa permintaan hanya diproses jika pengguna valid tersedia dalam \texttt{conn.assigns}. Jika tidak ada pengguna, aplikasi menghentikan proses dan mengalihkan pengguna ke halaman utama.

\subsubsection{Manfaat Menggunakan Plug \texttt{RequireAuth}}
Menggunakan plug \texttt{RequireAuth} memberikan beberapa keuntungan penting. Pertama, tingkat keamanan aplikasi meningkat karena tindakan yang sensitif hanya dapat diakses oleh pengguna yang telah login. Kedua, pengguna mendapatkan pengalaman yang lebih baik melalui pesan flash yang memberi tahu mengapa akses ditolak. Ketiga, mekanisme akses menjadi lebih mudah dikelola karena plug dapat diterapkan pada berbagai rute atau aksi tanpa perlu menulis ulang logika otorisasi.



\section{Alur Autentikasi dalam Aplikasi}

\subsection{Penyesuaian Layout Berdasarkan Status Autentikasi}
Tampilan aplikasi dapat disesuaikan berdasarkan status autentikasi pengguna agar pengalaman yang diberikan lebih relevan. Salah satu bentuk penyesuaian tersebut adalah menampilkan tautan \texttt{Signout} ketika pengguna sudah login, atau menampilkan tautan \texttt{Login with GitHub} ketika tidak ada pengguna yang terautentikasi. Pemeriksaan dilakukan menggunakan nilai \texttt{@user} yang sebelumnya ditetapkan oleh plug autentikasi seperti \texttt{SetUser}.

\begin{lstlisting}[language=html, caption={\texttt{lib/hiwi\_web/components/layouts.ex}}]
  ...
  <li>
    <%= if @user do %>
      <a href={~p"/auth/signout"} class="btn btn-ghost">Signout</a>
    <% else %>
      <a href={~p"/auth/github"} class="btn btn-ghost">Login with GitHub</a>
    <% end %>
  </li>
  <li>
    <a href="https://phoenixframework.org/" class="btn btn-ghost">Website</a>
  </li>
  ...
\end{lstlisting}

Pada kode tersebut, penyesuaian dilakukan dengan memeriksa \texttt{@user}. Nilai ini berasal dari \texttt{conn.assigns[:user]} yang telah diisi sebelumnya oleh plug. Jika nilai tersebut ada, berarti pengguna sedang login dan tautan yang ditampilkan adalah \texttt{Signout}, yang mengarah ke rute \texttt{/auth/signout}. Sebaliknya, jika tidak ada pengguna pada sesi, tampilan menunjukkan tautan \texttt{Login with GitHub} yang memulai proses autentikasi melalui GitHub. Dengan cara ini, navigasi tetap konsisten dengan status autentikasi pengguna, dan antarmuka memberikan petunjuk yang tepat mengenai tindakan yang dapat dilakukan.

\subsubsection{Manfaat Penyesuaian Layout Berdasarkan Status Autentikasi}
Penyesuaian layout berdasarkan status autentikasi memberikan beberapa keuntungan langsung. Pengguna memperoleh pengalaman yang lebih jelas karena antarmuka menunjukkan apakah mereka sedang login atau tidak. Tindakan yang ditampilkan menjadi lebih aman dan tidak membingungkan, sebab pengguna hanya melihat tautan yang relevan bagi kondisi mereka. Selain itu, alur interaksi menjadi lebih efisien karena aplikasi menyediakan pilihan yang sesuai tanpa memerlukan langkah tambahan dari pengguna.


\subsection{Pengaturan Rute untuk Autentikasi}
File \texttt{router.ex} mengatur alur permintaan autentikasi dengan menambahkan plug \texttt{SetUser} pada pipeline \texttt{:browser} dan mendefinisikan rute untuk proses login dan logout. Dengan konfigurasi ini, setiap permintaan yang melewati pipeline \texttt{:browser} akan terlebih dahulu mencoba memuat pengguna yang sedang login, sehingga informasi tersebut dapat digunakan oleh controller maupun layout.

\begin{lstlisting}[language=Elixir, caption={\texttt{lib/hiwi\_web/router.ex}}]
  ...
  pipeline :browser do
    plug :accepts, ["html"]
    ...
    plug HiwiWeb.Plugs.SetUser
  end
  ...
  scope "/auth", HiwiWeb do
    pipe_through :browser

    get "/signout", AuthController, :signout
    get "/:provider", AuthController, :request
    get "/:provider/callback", AuthController, :callback
  end
  ...
\end{lstlisting}

Pada bagian pipeline \texttt{:browser}, \texttt{HiwiWeb.Plugs.SetUser} dipanggil agar setiap permintaan yang menggunakan pipeline ini memiliki informasi pengguna di dalam \texttt{conn.assigns}. Hal ini membuat nilai \texttt{@user} tersedia di layout dan controller tanpa perlu memuat ulang data pengguna secara manual.

Blok \texttt{scope "/auth", HiwiWeb} mendefinisikan sekumpulan rute yang berada di bawah prefiks \texttt{/auth}. Semua rute di dalamnya menggunakan \texttt{pipe\_through :browser}, sehingga mendapatkan dukungan sesi, flash, dan plug \texttt{SetUser}. Rute \texttt{get "/signout", AuthController, :signout} menangani proses keluar (logout). Ketika rute ini diakses, \texttt{AuthController.signout/2} akan menghapus informasi sesi yang terkait dengan pengguna dan biasanya memberikan pesan konfirmasi bahwa proses keluar telah berhasil.

Rute \texttt{get "/:provider", AuthController, :request} digunakan untuk memulai proses autentikasi dengan penyedia pihak ketiga, misalnya GitHub. Setelah pengguna memberikan izin pada penyedia tersebut, respons akan dikirim kembali ke rute \texttt{get "/:provider/callback", AuthController, :callback}. Di titik inilah aplikasi membaca data yang diberikan oleh penyedia, mengidentifikasi pengguna, dan membuat sesi autentikasi baru.

\subsubsection{Peran Utama Rute \texttt{signout}}
Rute \texttt{/auth/signout} memiliki peran penting dalam pengelolaan sesi autentikasi. Melalui rute ini, pengguna dapat mengakhiri sesi login secara eksplisit dan aman. Setelah fungsi \texttt{signout} dijalankan, data sesi yang berkaitan dengan autentikasi dihapus sehingga permintaan berikutnya tidak lagi dianggap berasal dari pengguna yang sudah login. Praktik ini membantu mencegah akses tidak sah akibat sesi yang dibiarkan terbuka, sekaligus memberikan kejelasan kepada pengguna mengenai status autentikasi mereka. Dengan menempatkan logika keluar di dalam \texttt{AuthController}, aplikasi juga mendapatkan konsistensi dalam cara menangani sesi di seluruh bagian sistem.


\subsection{Menangani Signout dalam \texttt{AuthController}}
Fungsi \texttt{signout} dalam \texttt{AuthController} bertugas membersihkan sesi autentikasi pengguna dan mengarahkan ulang ke halaman utama. Langkah ini penting untuk memastikan bahwa sesi yang berjalan ditutup dengan benar dan tidak dapat digunakan lagi untuk mengakses halaman yang memerlukan autentikasi.

\begin{lstlisting}[language=Elixir, caption={\texttt{lib/hiwi\_web/controllers/auth\_controller.ex}}]
  ...
  def signout(conn, _params) do
    conn
    |> configure_session(drop: true)
    |> put_flash(:info, "Signout has been successful.")
    |> redirect(to: "/")
  end
  ...
\end{lstlisting}

Pada fungsi di atas, \texttt{configure\_session(drop: true)} digunakan untuk menghapus seluruh data sesi yang sedang aktif, termasuk informasi autentikasi seperti \texttt{user\_id}. Setelah sesi dibersihkan, \texttt{put\_flash/3} menambahkan pesan informasi \texttt{"Signout has been successful."} yang akan ditampilkan pada halaman berikutnya sebagai konfirmasi bahwa proses keluar telah berhasil. Langkah terakhir, \texttt{redirect(to: "/")}, mengarahkan pengguna kembali ke halaman utama aplikasi dalam keadaan sudah tidak lagi terautentikasi.

\subsubsection{Peran Penting Fungsi \texttt{signout}}
Fungsi \texttt{signout} memegang peran penting dalam menjaga keamanan dan konsistensi manajemen sesi. Dengan menghapus sesi secara menyeluruh, aplikasi mencegah kemungkinan akses tidak sah yang berasal dari sesi yang dibiarkan terbuka. Pesan flash yang ditampilkan setelah pengalihan juga membantu memberikan kejelasan kepada pengguna bahwa mereka telah benar-benar keluar dari sistem. Pendekatan terpusat melalui satu fungsi ini memastikan bahwa seluruh proses keluar mengikuti prosedur yang sama di seluruh aplikasi.




\section{Menerapkan Otorisasi dalam Controller}

\subsection{Mengamankan Aksi dalam \texttt{QueueController}}
\texttt{QueueController} dikonfigurasi untuk memastikan bahwa hanya pengguna yang telah terautentikasi dan memiliki hak akses yang benar yang dapat melakukan tindakan tertentu. Pengaturan ini melibatkan penggunaan plug \texttt{RequireAuth} untuk autentikasi dan plug \texttt{:check\_queue\_owner} untuk memverifikasi kepemilikan antrean sebelum tindakan sensitif dijalankan.

\begin{lstlisting}[language=Elixir, caption={\texttt{lib/hiwi\_web/controllers/queue\_controller.ex}}]
  ...
  plug HiwiWeb.Plugs.RequireAuth when action in [:new, :create, :update, :edit, :delete]
  plug :check_queue_owner when action in [:update, :edit, :delete]
  ...
  def create(conn, params) do
    %{"queue" => queue_params} = params

    changeset =
      conn.assigns.user
      |> Ecto.build_assoc(:queues)
      |> Queue.changeset(queue_params)
    
    case Repo.insert(changeset) do
      {:ok, _queue} ->
        conn
        |> put_flash(:info, "Queue created successfully.")
        |> redirect(to: "/")
      {:error, changeset} ->
        IO.inspect(changeset)
        render(conn, :new, changeset: changeset)
    end
  end
  ...
\end{lstlisting}

Pada baris pertama, plug \texttt{RequireAuth} memastikan bahwa tindakan seperti \texttt{new}, \texttt{create}, \texttt{update}, \texttt{edit}, dan \texttt{delete} hanya dapat diakses oleh pengguna yang telah login. Jika pengguna belum terautentikasi, permintaan dialihkan sebelum controller mengeksekusi tindakan tersebut. Plug kedua, yaitu \texttt{:check\_queue\_owner}, digunakan untuk memverifikasi bahwa pengguna yang sedang login adalah pemilik antrean sebelum melakukan \texttt{update}, \texttt{edit}, atau \texttt{delete}. Dengan verifikasi ini, hanya pemilik antrean yang dapat memodifikasinya.

\subsubsection{Implementasi Fungsi \texttt{create} dengan Otorisasi}
Fungsi \texttt{create} bertanggung jawab membuat antrean baru, sekaligus memastikan antrean tersebut terhubung dengan pengguna yang sedang login. Parameter permintaan dipetakan ke dalam \texttt{queue\_params}, kemudian asosiasi antara pengguna dan antrean baru dibentuk menggunakan \texttt{Ecto.build\_assoc}. Setelah itu, \texttt{Queue.changeset} digunakan untuk mempersiapkan data antrean sebelum disimpan ke database.

Kueri \texttt{Repo.insert} digunakan untuk menyimpan data. Jika proses penyimpanan berhasil, pengguna diarahkan kembali ke halaman utama dengan pesan keberhasilan. Jika terjadi kesalahan, tampilan formulir pembuatan antrean ditampilkan kembali dengan informasi error dari changeset.

\subsubsection{Keuntungan dari Konfigurasi Otorisasi dalam \texttt{QueueController}}
Konfigurasi ini memberikan perlindungan yang kuat terhadap tindakan sensitif dalam controller. Autentikasi memastikan bahwa tindakan yang penting hanya dapat dilakukan oleh pengguna yang login, sementara verifikasi kepemilikan memberi jaminan bahwa antrean hanya dapat dimodifikasi oleh pemiliknya. Selain meningkatkan keamanan, proses ini juga meningkatkan pengalaman pengguna dengan memberikan pesan flash yang jelas dan alur kerja yang konsisten saat mengelola antrean. Dengan demikian, controller dapat menjaga integritas data sekaligus memberikan pengalaman yang informatif dan terstruktur.


\subsection{Menampilkan Tautan Edit dan Delete Berdasarkan Kepemilikan Queue}
Pada tampilan \texttt{index.html.heex}, ditambahkan kondisi untuk menampilkan tautan \texttt{Edit} dan \texttt{Delete} hanya kepada pengguna yang memiliki antrean tersebut. Pemeriksaan dilakukan dengan membandingkan \texttt{@user.id} dengan \texttt{q.user\_id}. Jika kedua nilai cocok, maka pengguna dianggap sebagai pemilik antrean dan dapat melihat serta mengakses tindakan pengeditan atau penghapusan.

\begin{lstlisting}[language=HTML, caption={\texttt{lib/hiwi\_web/controllers/queue\_html/index.html.heex}}]
<Layouts.app flash={@flash} user={@user}>
  ...
  <div class="join">
    <.link navigate={~p"/queues/#{q.id}"} class="btn btn-ghost btn-xs join-item">View</.link>

    <%= if @user && @user.id == q.user_id do %>
      <.link navigate={~p"/queues/edit/#{q.id}"} class="btn btn-ghost btn-xs join-item">Edit</.link>
      <.link href={~p"/queues/delete/#{q.id}"} method="delete"
             data-confirm="Delete this queue?"
             class="btn btn-ghost btn-xs text-error join-item">
        Delete
      </.link>
    <% end %>
  </div>
  ...
</Layouts.app>
\end{lstlisting}

Pada cuplikan tersebut, nilai \texttt{@user} berasal dari \texttt{conn.assigns.user} yang telah ditetapkan oleh plug autentikasi. Jika nilai tersebut \texttt{nil}, tautan \texttt{Edit} dan \texttt{Delete} tidak akan muncul. Jika ada pengguna yang sedang login, aplikasi memeriksa apakah \texttt{@user.id} sama dengan \texttt{q.user\_id}. Kondisi ini memastikan bahwa hanya pemilik antrean yang dapat melihat tindakan pengeditan dan penghapusan.

\subsubsection{Penjelasan Tautan Edit dan Delete}
Tautan \texttt{Edit} menggunakan \texttt{navigate} untuk membawa pengguna ke halaman pengeditan antrean berdasarkan \texttt{id} antrean. Tautan \texttt{Delete} menggunakan atribut \texttt{method="delete"} untuk mengirim permintaan penghapusan dan dilengkapi dengan konfirmasi sehingga pengguna tidak menghapus antrean secara tidak sengaja. Kedua tautan ini hanya muncul ketika kondisi kepemilikan terpenuhi.

\subsubsection{Menambahkan Kondisi untuk Keamanan}
Kondisi ini memberikan lapisan keamanan tambahan dengan memastikan bahwa tindakan sensitif seperti mengubah atau menghapus antrean hanya dapat dilakukan oleh pemiliknya. Pendekatan ini membantu menjaga integritas data dan menghindari akses yang tidak sesuai, karena pengguna lain tidak dapat melihat atau mengakses tautan untuk tindakan tersebut.



\section{Kesimpulan}
Penambahan pengecekan kepemilikan pada komponen tampilan memastikan bahwa hanya pengguna yang benar-benar memiliki antrean yang dapat melakukan tindakan seperti mengedit atau menghapus. Pendekatan ini selaras dengan praktik terbaik dalam pengembangan aplikasi web, di mana hak akses harus sesuai dengan peran serta kepemilikan data. Dengan memadukan penggunaan plugs untuk autentikasi dan otorisasi di sisi server, serta pengecekan kepemilikan di sisi tampilan, aplikasi Phoenix memperoleh lapisan keamanan tambahan yang menjaga integritas data dan mencegah tindakan yang tidak sah.

